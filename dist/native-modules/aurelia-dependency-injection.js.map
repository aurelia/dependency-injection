{"version":3,"file":"aurelia-dependency-injection.js","sources":["../../node_modules/tslib/tslib.es6.js","../../../src/injection.ts","../../../src/resolvers.ts","../../../src/container.ts","../../../src/invokers.ts","../../../src/registrations.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import { metadata } from 'aurelia-metadata';\r\nimport { _emptyParameters } from './container';\r\nimport { Args, Impl, DependencyCtor } from './types';\r\n\r\n// tslint:disable-next-line:ban-types\r\nexport type Injectable = Function & { inject?: any[] | (() => any[]) };\r\n\r\nfunction isInjectable(potentialTarget: any): potentialTarget is Injectable {\r\n  return !!potentialTarget;\r\n}\r\n\r\n/**\r\n * Decorator: Directs the TypeScript transpiler to write-out type metadata for\r\n * the decorated class.\r\n */\r\nexport function autoinject<TPotential>(\r\n  potentialTarget?: TPotential\r\n): TPotential extends Injectable ? void : (target: Injectable) => void {\r\n  const deco = (target: Injectable): void => {\r\n    if (!target.hasOwnProperty('inject')) {\r\n      target.inject = (\r\n        (metadata.getOwn(metadata.paramTypes, target) as any[]) ||\r\n        _emptyParameters\r\n      ).slice();\r\n      if (target.inject && target.inject.length > 0) {\r\n        // TypeScript 3.0 metadata for \"...rest\" gives type \"Object\"\r\n        // if last parameter is \"Object\", assume it's a ...rest and remove that\r\n        // metadata.\r\n        if (target.inject[target.inject.length - 1] === Object) {\r\n          target.inject.splice(-1, 1);\r\n        }\r\n      }\r\n    }\r\n  };\r\n  if (isInjectable(potentialTarget)) {\r\n    return deco(potentialTarget) as TPotential extends Injectable ? void : (target: Injectable) => void;\r\n  }\r\n  return deco as TPotential extends Injectable ? void : (target: Injectable) => void;\r\n}\r\n/**\r\n * Decorator: Specifies the dependencies that should be injected by the DI Container into the decorated class/function.\r\n */\r\nexport function inject<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>\r\n>(...rest: TArgs[number][]): any {\r\n  return (\r\n    target: DependencyCtor<TBase, TImpl, TArgs> & { inject: any },\r\n    _key: any,\r\n    descriptor: any) => {\r\n    // handle when used as a constructor parameter decorator\r\n    if (typeof descriptor === 'number') {\r\n      autoinject(target);\r\n      if (rest.length === 1) {\r\n        target.inject[descriptor] = rest[0];\r\n      }\r\n      return;\r\n    }\r\n    // if it's true then we injecting rest into function and not Class constructor\r\n    if (descriptor) {\r\n      const fn = descriptor.value;\r\n      fn.inject = rest;\r\n    } else {\r\n      target.inject = rest;\r\n    }\r\n  };\r\n}\r\n","import { protocol } from 'aurelia-metadata';\r\nimport { Container } from './container';\r\nimport { autoinject } from './injection';\r\nimport type {\r\n  PrimitiveOrDependencyCtor,\r\n  DependencyCtorOrFunctor,\r\n  PrimitiveOrDependencyCtorOrFunctor,\r\n  DependencyCtor,\r\n  DependencyFunctor,\r\n  ImplOrAny,\r\n  Impl,\r\n  Args\r\n} from './types';\r\n\r\n/**\r\n * Decorator: Indicates that the decorated class/object is a custom resolver.\r\n */\r\nexport const resolver: {\r\n  decorates?: (key: any) => key is { get(container: Container, key: any): any };\r\n} & (() => any) = ((protocol as unknown) as { create(...args: any[]): any }).create(\r\n  'aurelia:resolver',\r\n  (target): string | boolean => {\r\n    if (!(typeof target.get === 'function')) {\r\n      return 'Resolvers must implement: get(container: Container, key: any): any';\r\n    }\r\n\r\n    return true;\r\n  }\r\n);\r\n\r\n/**\r\n * Used to allow functions/classes to specify custom dependency resolution logic.\r\n */\r\nexport interface Resolver {\r\n  /**\r\n   * Called by the container to allow custom resolution of dependencies for a\r\n   * function/class.\r\n   * @param container The container to resolve from.\r\n   * @param key The key that the resolver was registered as.\r\n   * @return Returns the resolved object.\r\n   */\r\n  get(container: Container, key: any): any;\r\n}\r\n\r\nexport enum Strategy {\r\n  instance = 0,\r\n  singleton = 1,\r\n  transient = 2,\r\n  function = 3,\r\n  array = 4,\r\n  alias = 5\r\n}\r\nexport type IStrategy = 1 | 2 | 3 | 4 | 5;\r\n\r\nexport type StrategyFunctor<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>\r\n  > = (\r\n    container?: Container,\r\n    ctor?: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n    strategyResolver?: any\r\n  ) => TImpl;\r\n\r\nexport interface StrategyState<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>\r\n  > {\r\n  [Strategy.instance]: TImpl;\r\n  [Strategy.singleton]: DependencyCtorOrFunctor<TBase, TImpl, TArgs>;\r\n  [Strategy.transient]: DependencyCtorOrFunctor<TBase, TImpl, TArgs>;\r\n  [Strategy.function]: StrategyFunctor<TBase, TImpl, TArgs>;\r\n  /**\r\n   * For typings purposes, this is done as ({ get: StrategyFunctor } | TImpl)[]\r\n   * But it should be understood, and used as [{ get: StrategyFunctor }, ...TImp[]]\r\n   */\r\n  [Strategy.array]: ({\r\n    get: (\r\n      container: Container,\r\n      key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>\r\n    ) => TImpl\r\n  } | TImpl)[];\r\n  [Strategy.alias]: any;\r\n}\r\n\r\nfunction isStrategy<\r\n  TBase,\r\n  TImpl extends Impl<TBase>,\r\n  TArgs extends Args<TBase>,\r\n  TKey extends keyof StrategyState<TBase, TImpl, TArgs>\r\n>(\r\n  actual: Strategy,\r\n  expected: TKey,\r\n  state):\r\n  state is StrategyState<TBase, TImpl, TArgs>[TKey] {\r\n  return actual === expected;\r\n}\r\n/**\r\n * Used to resolve instances, singletons, transients, aliases\r\n */\r\n@resolver()\r\nexport class StrategyResolver<\r\n  TBase,\r\n  TImpl extends Impl<TBase>,\r\n  TArgs extends Args<TBase>,\r\n  TStrategyKey extends keyof StrategyState<TBase, TImpl, TArgs>> {\r\n\r\n  public strategy: keyof StrategyState<TBase, TImpl, TArgs>;\r\n  public state: StrategyState<TBase, TImpl, TArgs>[keyof StrategyState<TBase, TImpl, TArgs>];\r\n\r\n  /**\r\n   * Creates an instance of the StrategyResolver class.\r\n   * @param strategy The type of resolution strategy.\r\n   * @param state The state associated with the resolution strategy.\r\n   */\r\n  constructor(strategy: TStrategyKey, state: StrategyState<TBase, TImpl, TArgs>[TStrategyKey]) {\r\n    this.strategy = strategy;\r\n    this.state = state;\r\n  }\r\n\r\n  /**\r\n   * Called by the container to allow custom resolution of dependencies for a\r\n   * function/class.\r\n   * @param container The container to resolve from.\r\n   * @param key The key that the resolver was registered as.\r\n   * @return Returns the resolved object.\r\n   */\r\n  public get(container: Container, key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>) {\r\n    if (isStrategy<TBase, TImpl, TArgs, Strategy.instance>(this.strategy, Strategy.instance, this.state)) {\r\n      return this.state;\r\n    }\r\n    if (isStrategy<TBase, TImpl, TArgs, Strategy.singleton>(this.strategy, Strategy.singleton, this.state)) {\r\n      const singleton = container.invoke<TBase, TImpl, TArgs>(this.state);\r\n      this.state = singleton;\r\n      this.strategy = 0;\r\n      return singleton;\r\n    }\r\n    if (isStrategy<TBase, TImpl, TArgs, Strategy.transient>(this.strategy, Strategy.transient, this.state)) {\r\n      return container.invoke<TBase, TImpl, TArgs>(this.state);\r\n    }\r\n    if (isStrategy<TBase, TImpl, TArgs, Strategy.function>(this.strategy, Strategy.function, this.state)) {\r\n      return this.state(container, key, this);\r\n    }\r\n    if (isStrategy<TBase, TImpl, TArgs, Strategy.array>(this.strategy, Strategy.array, this.state)) {\r\n      return (this.state[0] as { get: StrategyFunctor<TBase, TImpl, TArgs> }).get(container, key);\r\n    }\r\n    if (isStrategy<TBase, TImpl, TArgs, Strategy.alias>(this.strategy, Strategy.alias, this.state)) {\r\n      return container.get(this.state) as TImpl;\r\n    }\r\n    throw new Error('Invalid strategy: ' + this.strategy);\r\n  }\r\n}\r\n\r\n/**\r\n * Used to allow functions/classes to specify lazy resolution logic.\r\n */\r\n@resolver()\r\nexport class Lazy<TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>> {\r\n  /** @internal */\r\n  public _key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>;\r\n\r\n  /**\r\n   * A non existent property to help TS distinguish resolvers\r\n   *\r\n   * This is semi-private, and should not be used by application\r\n   */\r\n  __resolver_type__!: 'lazy';\r\n\r\n  /**\r\n   * Creates an instance of the Lazy class.\r\n   * @param key The key to lazily resolve.\r\n   */\r\n  constructor(key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>) {\r\n    this._key = key;\r\n  }\r\n\r\n  /**\r\n   * Called by the container to lazily resolve the dependency into a lazy locator\r\n   * function.\r\n   * @param container The container to resolve from.\r\n   * @return Returns a function which can be invoked at a later time to obtain\r\n   * the actual dependency.\r\n   */\r\n  public get(container: Container): () => ImplOrAny<TImpl> {\r\n    return () => container.get<TBase, TImpl, TArgs>(this._key);\r\n  }\r\n\r\n  /**\r\n   * Creates a Lazy Resolver for the supplied key.\r\n   * @param key The key to lazily resolve.\r\n   * @return Returns an instance of Lazy for the key.\r\n   */\r\n  public static of<\r\n    TBase,\r\n    TImpl extends Impl<TBase> = Impl<TBase>,\r\n    TArgs extends Args<TBase> = Args<TBase>>(\r\n      key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>\r\n    ) {\r\n    return new Lazy<TBase, TImpl, TArgs>(key);\r\n  }\r\n}\r\n\r\n/**\r\n * Used to allow functions/classes to specify resolution of all matches to a key.\r\n */\r\n@resolver()\r\nexport class All<TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>> {\r\n  /** @internal */\r\n  public _key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>;\r\n\r\n  /**\r\n   * A non existent property to help TS distinguish resolvers\r\n   *\r\n   * This is semi-private, and should not be used by application\r\n   */\r\n  __resolver_type__!: 'all';\r\n\r\n  /**\r\n   * Creates an instance of the All class.\r\n   * @param key The key to lazily resolve all matches for.\r\n   */\r\n  constructor(key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>) {\r\n    this._key = key;\r\n  }\r\n\r\n  /**\r\n   * Called by the container to resolve all matching dependencies as an array of\r\n   * instances.\r\n   * @param container The container to resolve from.\r\n   * @return Returns an array of all matching instances.\r\n   */\r\n  public get(container: Container): TImpl[] {\r\n    return container.getAll(this._key);\r\n  }\r\n\r\n  /**\r\n   * Creates an All Resolver for the supplied key.\r\n   * @param key The key to resolve all instances for.\r\n   * @return Returns an instance of All for the key.\r\n   */\r\n  public static of<TBase,\r\n    TImpl extends Impl<TBase> = Impl<TBase>,\r\n    TArgs extends Args<TBase> = Args<TBase>>(\r\n      key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>\r\n    ): All<TBase, TImpl, TArgs> {\r\n    return new All(key);\r\n  }\r\n}\r\n\r\n/**\r\n * Used to allow functions/classes to specify an optional dependency, which will\r\n * be resolved only if already registred with the container.\r\n */\r\n@resolver()\r\nexport class Optional<TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>> {\r\n  /** @internal */\r\n  public _key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>;\r\n\r\n  /** @internal */\r\n  public _checkParent: boolean;\r\n\r\n  /**\r\n   * A non existent property to help TS distinguish resolvers\r\n   *\r\n   * This is semi-private, and should not be used by application\r\n   */\r\n  __resolver_type__!: 'optional';\r\n\r\n  /**\r\n   * Creates an instance of the Optional class.\r\n   * @param key The key to optionally resolve for.\r\n   * @param checkParent Indicates whether or not the parent container hierarchy\r\n   * should be checked.\r\n   */\r\n  constructor(key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>, checkParent: boolean = true) {\r\n    this._key = key;\r\n    this._checkParent = checkParent;\r\n  }\r\n\r\n  /**\r\n   * Called by the container to provide optional resolution of the key.\r\n   * @param container The container to resolve from.\r\n   * @return Returns the instance if found; otherwise null.\r\n   */\r\n  public get(container: Container): TImpl | null {\r\n    if (container.hasResolver(this._key, this._checkParent)) {\r\n      return container.get(this._key);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Creates an Optional Resolver for the supplied key.\r\n   * @param key The key to optionally resolve for.\r\n   * @param [checkParent=true] Indicates whether or not the parent container\r\n   * hierarchy should be checked.\r\n   * @return Returns an instance of Optional for the key.\r\n   */\r\n  public static of<TBase,\r\n    TImpl extends Impl<TBase> = Impl<TBase>,\r\n    TArgs extends Args<TBase> = Args<TBase>>(\r\n      key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>,\r\n      checkParent: boolean = true): Optional<TBase, TImpl, TArgs> {\r\n    return new Optional(key, checkParent);\r\n  }\r\n}\r\n\r\n/**\r\n * Used to inject the dependency from the parent container instead of the current\r\n * one.\r\n */\r\n@resolver()\r\nexport class Parent<TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>> {\r\n  /** @internal */\r\n  public _key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>;\r\n\r\n  /**\r\n   * A non existent property to help TS distinguish resolvers\r\n   *\r\n   * This is semi-private, and should not be used by application\r\n   */\r\n  __resolver_type__!: 'parent';\r\n\r\n  /**\r\n   * Creates an instance of the Parent class.\r\n   * @param key The key to resolve from the parent container.\r\n   */\r\n  constructor(key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>) {\r\n    this._key = key;\r\n  }\r\n\r\n  /**\r\n   * Called by the container to load the dependency from the parent container\r\n   * @param container The container to resolve the parent from.\r\n   * @return Returns the matching instance from the parent container\r\n   */\r\n  public get(container: Container): TImpl | null {\r\n    return container.parent ? container.parent.get(this._key) : null;\r\n  }\r\n\r\n  /**\r\n   * Creates a Parent Resolver for the supplied key.\r\n   * @param key The key to resolve.\r\n   * @return Returns an instance of Parent for the key.\r\n   */\r\n  public static of<TBase,\r\n    TImpl extends Impl<TBase> = Impl<TBase>,\r\n    TArgs extends Args<TBase> = Args<TBase>>(\r\n      key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>\r\n    ): Parent<TBase, TImpl, TArgs> {\r\n    return new Parent(key);\r\n  }\r\n}\r\n\r\n/**\r\n * Used to allow injecting dependencies but also passing data to the constructor.\r\n */\r\n@resolver()\r\nexport class Factory<TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>> {\r\n  /** @internal */\r\n  public _key: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>;\r\n\r\n  /**\r\n   * A non existent property to help TS distinguish resolvers\r\n   *\r\n   * This is semi-private, and should not be used by application\r\n   */\r\n  __resolver_type__!: 'factory';\r\n\r\n  /**\r\n   * Creates an instance of the Factory class.\r\n   * @param key The key to resolve from the parent container.\r\n   */\r\n  constructor(key: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>) {\r\n    this._key = key;\r\n  }\r\n\r\n  /**\r\n   * Called by the container to pass the dependencies to the constructor.\r\n   * @param container The container to invoke the constructor with dependencies\r\n   * and other parameters.\r\n   * @return Returns a function that can be invoked to resolve dependencies\r\n   * later, and the rest of the parameters.\r\n   */\r\n  public get(container: Container): DependencyFunctor<TBase, TImpl, TArgs> {\r\n    let fn = this._key;\r\n    const resolver = container.getResolver(fn);\r\n    if (resolver && resolver.strategy === Strategy.function) {\r\n      fn = resolver.state;\r\n    }\r\n\r\n    return (...rest) => container.invoke(fn as DependencyCtorOrFunctor<TBase, TImpl, TArgs>, rest);\r\n  }\r\n\r\n  /**\r\n   * Creates a Factory Resolver for the supplied key.\r\n   * @param key The key to resolve.\r\n   * @return Returns an instance of Factory for the key.\r\n   */\r\n  public static of<TBase,\r\n    TImpl extends Impl<TBase> = Impl<TBase>,\r\n    TArgs extends Args<TBase> = Args<TBase>>(\r\n      key: DependencyCtor<TBase, TImpl, TArgs>\r\n    ): Factory<TBase, TImpl, TArgs> {\r\n    return new Factory(key);\r\n  }\r\n}\r\n\r\n/**\r\n * Used to inject a new instance of a dependency, without regard for existing\r\n * instances in the container. Instances can optionally be registered in the\r\n * container\r\n * under a different key by supplying a key using the `as` method.\r\n */\r\n@resolver()\r\nexport class NewInstance<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>> {\r\n  /** @internal */\r\n  public key: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>;\r\n  /** @internal */\r\n  public asKey: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>;\r\n  /** @internal */\r\n  public dynamicDependencies: TArgs[number][];\r\n\r\n  /**\r\n   * A non existent property to help TS distinguish resolvers\r\n   *\r\n   * This is semi-private, and should not be used by application\r\n   */\r\n  __resolver_type__!: 'newInstance';\r\n\r\n  /**\r\n   * Creates an instance of the NewInstance class.\r\n   * @param key The key to resolve/instantiate.\r\n   * @param dynamicDependencies An optional list of dynamic dependencies.\r\n   */\r\n  constructor(key: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>, ...dynamicDependencies: TArgs[number][]) {\r\n    this.key = key;\r\n    this.asKey = key;\r\n    this.dynamicDependencies = dynamicDependencies;\r\n  }\r\n\r\n  /**\r\n   * Called by the container to instantiate the dependency and potentially\r\n   * register\r\n   * as another key if the `as` method was used.\r\n   * @param container The container to resolve the parent from.\r\n   * @return Returns the matching instance from the parent container\r\n   */\r\n  public get(container: Container) {\r\n    const dynamicDependencies =\r\n      this.dynamicDependencies.length > 0\r\n        ? this.dynamicDependencies.map(dependency =>\r\n          dependency['protocol:aurelia:resolver']\r\n            ? dependency.get(container)\r\n            : container.get(dependency)\r\n        )\r\n        : undefined;\r\n\r\n    let fn = this.key;\r\n    const resolver = container.getResolver(fn);\r\n    if (resolver && resolver.strategy === 3) {\r\n      fn = resolver.state;\r\n    }\r\n\r\n    const instance = container.invoke(fn as DependencyCtorOrFunctor<TBase, TImpl, TArgs>, dynamicDependencies);\r\n    container.registerInstance(this.asKey, instance);\r\n    return instance;\r\n  }\r\n\r\n  /**\r\n   * Instructs the NewInstance resolver to register the resolved instance using\r\n   * the supplied key.\r\n   * @param key The key to register the instance with.\r\n   * @return Returns the NewInstance resolver.\r\n   */\r\n  public as(key: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>) {\r\n    this.asKey = key;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Creates an NewInstance Resolver for the supplied key.\r\n   * @param key The key to resolve/instantiate.\r\n   * @param dynamicDependencies An optional list of dynamic dependencies.\r\n   * @return Returns an instance of NewInstance for the key.\r\n   */\r\n  public static of<TBase,\r\n    TImpl extends Impl<TBase> = Impl<TBase>,\r\n    TArgs extends Args<TBase> = Args<TBase>>(\r\n      key: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n      ...dynamicDependencies: TArgs[number][]): NewInstance<TBase, TImpl, TArgs> {\r\n    return new NewInstance(key, ...dynamicDependencies);\r\n  }\r\n}\r\n\r\n/**\r\n * Used by parameter decorators to call autoinject for the target and retrieve\r\n * the target's inject property.\r\n * @param target The target class.\r\n * @return Returns the target's own inject property.\r\n */\r\nexport function getDecoratorDependencies<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>>(\r\n    target: DependencyCtor<TBase, TImpl, TArgs> & { inject?: TArgs[number][] }\r\n  ) {\r\n  autoinject(target);\r\n\r\n  return target.inject;\r\n}\r\n\r\n/**\r\n * Decorator: Specifies the dependency should be lazy loaded\r\n */\r\nexport function lazy<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>>(\r\n    keyValue: any\r\n  ) {\r\n  return (\r\n    target: { new (...args: TArgs): TBase | TImpl },\r\n    _key,\r\n    index: number\r\n  ) => {\r\n    const inject = getDecoratorDependencies(target)!;\r\n    inject[index] = Lazy.of(keyValue);\r\n  };\r\n}\r\n\r\n/**\r\n * Decorator: Specifies the dependency should load all instances of the given\r\n * key.\r\n */\r\nexport function all<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>>(\r\n    keyValue: any\r\n  ) {\r\n  return (\r\n    target: DependencyCtor<TBase, TImpl, TArgs> & { inject?: TArgs[number][] },\r\n    _key,\r\n    index: number\r\n  ) => {\r\n    const inject = getDecoratorDependencies(target)!;\r\n    inject[index] = All.of(keyValue);\r\n  };\r\n}\r\n\r\n/**\r\n * Decorator: Specifies the dependency as optional\r\n */\r\nexport function optional<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>>(\r\n    checkParentOrTarget: boolean = true) {\r\n  const deco = (checkParent: boolean) => {\r\n    return (\r\n      target: DependencyCtor<TBase, TImpl, TArgs> & { inject?: TArgs[number][] },\r\n      _key,\r\n      index: number) => {\r\n      const inject = getDecoratorDependencies(target)!;\r\n      inject[index] = Optional.of(inject[index], checkParent);\r\n    };\r\n  };\r\n  if (typeof checkParentOrTarget === 'boolean') {\r\n    return deco(checkParentOrTarget);\r\n  }\r\n  return deco(true);\r\n}\r\n\r\n/**\r\n * Decorator: Specifies the dependency to look at the parent container for\r\n * resolution\r\n */\r\nexport function parent<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>>(\r\n    target: DependencyCtor<TBase, TImpl, TArgs> & { inject?: TArgs[number][] },\r\n    _key,\r\n    index: number) {\r\n  const inject = getDecoratorDependencies(target)!;\r\n  inject[index] = Parent.of(inject[index]);\r\n}\r\n\r\n/**\r\n * Decorator: Specifies the dependency to create a factory method, that can\r\n * accept optional arguments\r\n */\r\nexport function factory<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>>(\r\n    keyValue: any\r\n  ) {\r\n  return (\r\n    target: DependencyCtor<TBase, TImpl, TArgs> & { inject?: TArgs[number][] },\r\n    _key,\r\n    index: number\r\n  ) => {\r\n    const inject = getDecoratorDependencies(target)!;\r\n    inject[index] = Factory.of(keyValue);\r\n  };\r\n}\r\n\r\n/**\r\n * Decorator: Specifies the dependency as a new instance. Instances can optionally be registered in the container\r\n * under a different key and/or use dynamic dependencies\r\n */\r\nexport function newInstance<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>\r\n>(\r\n  asKeyOrTarget?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs> & { inject?: TArgs[number][] },\r\n  ...dynamicDependencies: TArgs[number][]\r\n) {\r\n  const deco = (asKey?: typeof asKeyOrTarget) => {\r\n    return (\r\n      target: { new (...args: any[]): any },\r\n      _key,\r\n      index: number\r\n    ) => {\r\n      const inject = getDecoratorDependencies(target)!;\r\n      inject[index] = NewInstance.of(inject[index], ...dynamicDependencies);\r\n      if (!!asKey) {\r\n        inject[index].as(asKey);\r\n      }\r\n    };\r\n  };\r\n  if (arguments.length >= 1) {\r\n    return deco(asKeyOrTarget);\r\n  }\r\n  return deco();\r\n}\r\n","import './internal';\r\nimport { metadata } from 'aurelia-metadata';\r\nimport { AggregateError } from 'aurelia-pal';\r\nimport { resolver, StrategyResolver, Resolver, Strategy, StrategyState, Factory, NewInstance, Lazy, Optional, All, Parent } from './resolvers';\r\nimport { Invoker } from './invokers';\r\nimport {\r\n  DependencyCtorOrFunctor,\r\n  DependencyCtor,\r\n  PrimitiveOrDependencyCtor,\r\n  PrimitiveOrDependencyCtorOrFunctor,\r\n  ImplOrAny,\r\n  Impl,\r\n  Args,\r\n  Primitive\r\n} from './types';\r\n\r\nlet currentContainer: Container | null = null;\r\n\r\nfunction validateKey(key: any) {\r\n  if (key === null || key === undefined) {\r\n    throw new Error(\r\n      'key/value cannot be null or undefined. Are you trying to inject/register something that doesn\\'t exist with DI?'\r\n    );\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport const _emptyParameters = Object.freeze([]) as [];\r\n\r\nmetadata.registration = 'aurelia:registration';\r\nmetadata.invoker = 'aurelia:invoker';\r\n\r\nconst resolverDecorates = resolver.decorates!;\r\n\r\n/**\r\n * Stores the information needed to invoke a function.\r\n */\r\nexport class InvocationHandler<\r\n  TBase,\r\n  TImpl extends Impl<TBase>,\r\n  TArgs extends Args<TBase>\r\n  > {\r\n  /**\r\n   * The function to be invoked by this handler.\r\n   */\r\n  public fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>;\r\n\r\n  /**\r\n   * The invoker implementation that will be used to actually invoke the function.\r\n   */\r\n  public invoker: Invoker<TBase, TImpl, TArgs>;\r\n\r\n  /**\r\n   * The statically known dependencies of this function invocation.\r\n   */\r\n  public dependencies: TArgs;\r\n\r\n  /**\r\n   * Instantiates an InvocationDescription.\r\n   * @param fn The Function described by this description object.\r\n   * @param invoker The strategy for invoking the function.\r\n   * @param dependencies The static dependencies of the function call.\r\n   */\r\n  constructor(\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n    invoker: Invoker<TBase, TImpl, TArgs>,\r\n    dependencies: TArgs\r\n  ) {\r\n    this.fn = fn;\r\n    this.invoker = invoker;\r\n    this.dependencies = dependencies;\r\n  }\r\n\r\n  /**\r\n   * Invokes the function.\r\n   * @param container The calling container.\r\n   * @param dynamicDependencies Additional dependencies to use during invocation.\r\n   * @return The result of the function invocation.\r\n   */\r\n  public invoke(container: Container, dynamicDependencies?: TArgs[]): TImpl {\r\n    const previousContainer = currentContainer;\r\n    currentContainer = container;\r\n    try {\r\n      return dynamicDependencies !== undefined\r\n        ? this.invoker.invokeWithDynamicDependencies(\r\n          container,\r\n          this.fn,\r\n          this.dependencies,\r\n          dynamicDependencies\r\n        )\r\n        : this.invoker.invoke(container, this.fn, this.dependencies);\r\n    } finally {\r\n      currentContainer = previousContainer;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Used to configure a Container instance.\r\n */\r\nexport interface ContainerConfiguration {\r\n  /**\r\n   * An optional callback which will be called when any function needs an\r\n   * InvocationHandler created (called once per Function).\r\n   */\r\n  onHandlerCreated?: (\r\n    handler: InvocationHandler<any, any, any>\r\n  ) => InvocationHandler<any, any, any>;\r\n\r\n  handlers?: Map<any, any>;\r\n}\r\n\r\nfunction invokeWithDynamicDependencies<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>\r\n>(\r\n  container: Container,\r\n  fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n  staticDependencies: TArgs[number][],\r\n  dynamicDependencies: TArgs[number][]\r\n) {\r\n  let i = staticDependencies.length;\r\n  let args = new Array(i);\r\n  let lookup;\r\n\r\n  while (i--) {\r\n    lookup = staticDependencies[i];\r\n\r\n    if (lookup === null || lookup === undefined) {\r\n      throw new Error(\r\n        'Constructor Parameter with index ' +\r\n        i +\r\n        ' cannot be null or undefined. Are you trying to inject/register something that doesn\\'t exist with DI?'\r\n      );\r\n    } else {\r\n      args[i] = container.get(lookup);\r\n    }\r\n  }\r\n\r\n  if (dynamicDependencies !== undefined) {\r\n    args = args.concat(dynamicDependencies);\r\n  }\r\n\r\n  return Reflect.construct(fn, args);\r\n}\r\n\r\nconst classInvoker: Invoker<any, any, any> = {\r\n  invoke(container, Type: DependencyCtor<any, any, any>, deps) {\r\n    const instances = deps.map((dep) => container.get(dep));\r\n    return Reflect.construct(Type, instances);\r\n  },\r\n  invokeWithDynamicDependencies\r\n};\r\n\r\nfunction getDependencies(f) {\r\n  if (!f.hasOwnProperty('inject')) {\r\n    return [];\r\n  }\r\n\r\n  if (typeof f.inject === 'function') {\r\n    return f.inject();\r\n  }\r\n\r\n  return f.inject;\r\n}\r\n\r\n/**\r\n * A lightweight, extensible dependency injection container.\r\n */\r\nexport class Container {\r\n  /**\r\n   * The global root Container instance. Available if makeGlobal() has been\r\n   * called. Aurelia Framework calls makeGlobal().\r\n   */\r\n  public static instance: Container;\r\n\r\n  /**\r\n   * The parent container in the DI hierarchy.\r\n   */\r\n  public parent: Container | null;\r\n\r\n  /**\r\n   * The root container in the DI hierarchy.\r\n   */\r\n  public root: Container;\r\n\r\n  /** @internal */\r\n  public _configuration: ContainerConfiguration;\r\n\r\n  /** @internal */\r\n  public _onHandlerCreated: (\r\n    handler: InvocationHandler<any, any, any>\r\n  ) => InvocationHandler<any, any, any>;\r\n\r\n  /** @internal */\r\n  public _handlers: Map<any, any>;\r\n\r\n  /** @internal */\r\n  public _resolvers: Map<any, any>;\r\n\r\n  /**\r\n   * Creates an instance of Container.\r\n   * @param configuration Provides some configuration for the new Container instance.\r\n   */\r\n  constructor(configuration?: ContainerConfiguration) {\r\n    if (configuration === undefined) {\r\n      configuration = {};\r\n    }\r\n\r\n    this._configuration = configuration;\r\n    this._onHandlerCreated = configuration.onHandlerCreated!;\r\n    this._handlers =\r\n      configuration.handlers || (configuration.handlers = new Map());\r\n    this._resolvers = new Map();\r\n    this.root = this;\r\n    this.parent = null;\r\n  }\r\n\r\n  /**\r\n   * Makes this container instance globally reachable through Container.instance.\r\n   */\r\n  public makeGlobal(): Container {\r\n    Container.instance = this;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets an invocation handler creation callback that will be called when new\r\n   * InvocationsHandlers are created (called once per Function).\r\n   * @param onHandlerCreated The callback to be called when an\r\n   * InvocationsHandler is created.\r\n   */\r\n  public setHandlerCreatedCallback<\r\n    TBase,\r\n    TImpl extends Impl<TBase> = Impl<TBase>,\r\n    TArgs extends Args<TBase> = Args<TBase>>(\r\n      onHandlerCreated: (\r\n        handler: InvocationHandler<TBase, TImpl, TArgs>\r\n      ) => InvocationHandler<TBase, TImpl, TArgs>\r\n    ) {\r\n    this._onHandlerCreated = onHandlerCreated;\r\n    this._configuration.onHandlerCreated = onHandlerCreated;\r\n  }\r\n\r\n  /**\r\n   * Registers an existing object instance with the container.\r\n   * @param key The key that identifies the dependency at resolution time;\r\n   * usually a constructor function.\r\n   * @param instance The instance that will be resolved when the key is matched.\r\n   * This defaults to the key value when instance is not supplied.\r\n   * @return The resolver that was registered.\r\n   */\r\n  public registerInstance<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>,\r\n    instance?: TImpl): Resolver {\r\n    return this.registerResolver(\r\n      key,\r\n      new StrategyResolver(0, instance === undefined ? key : instance)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Registers a type (constructor function) such that the container always\r\n   * returns the same instance for each request.\r\n   * @param key The key that identifies the dependency at resolution time;\r\n   * usually a constructor function.\r\n   * @param fn The constructor function to use when the dependency needs to be\r\n   * instantiated. This defaults to the key value when fn is not supplied.\r\n   * @return The resolver that was registered.\r\n   */\r\n  public registerSingleton<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: Primitive, fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver;\r\n  public registerSingleton<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: DependencyCtor<TBase, TImpl, TArgs>, fn?: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver;\r\n  public registerSingleton<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>, fn?: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver {\r\n    return this.registerResolver(\r\n      key,\r\n      new StrategyResolver(Strategy.singleton, fn === undefined ? key as DependencyCtor<TBase, TImpl, TArgs> : fn)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Registers a type (constructor function) such that the container returns a\r\n   * new instance for each request.\r\n   * @param key The key that identifies the dependency at resolution time;\r\n   * usually a constructor function.\r\n   * @param fn The constructor function to use when the dependency needs to be\r\n   * instantiated. This defaults to the key value when fn is not supplied.\r\n   * @return The resolver that was registered.\r\n   */\r\n  public registerTransient<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: Primitive, fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver;\r\n  public registerTransient<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: DependencyCtor<TBase, TImpl, TArgs>, fn?: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver;\r\n  public registerTransient<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>, fn?: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver {\r\n    return this.registerResolver(\r\n      key,\r\n      new StrategyResolver(2, fn === undefined ? key as DependencyCtor<TBase, TImpl, TArgs> : fn)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Registers a custom resolution function such that the container calls this\r\n   * function for each request to obtain the instance.\r\n   * @param key The key that identifies the dependency at resolution time;\r\n   * usually a constructor function.\r\n   * @param handler The resolution function to use when the dependency is\r\n   * needed.\r\n   * @return The resolver that was registered.\r\n   */\r\n  public registerHandler<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>,\r\n    handler: (container?: Container, key?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>, resolver?: Resolver) => any\r\n  ): Resolver {\r\n    return this.registerResolver(\r\n      key,\r\n      new StrategyResolver<TBase, TImpl, TArgs, Strategy.function>(Strategy.function, handler)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Registers an additional key that serves as an alias to the original DI key.\r\n   * @param originalKey The key that originally identified the dependency; usually a constructor function.\r\n   * @param aliasKey An alternate key which can also be used to resolve the same dependency  as the original.\r\n   * @return The resolver that was registered.\r\n   */\r\n  public registerAlias<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    originalKey: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>,\r\n    aliasKey: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>): Resolver {\r\n    return this.registerResolver(\r\n      aliasKey,\r\n      new StrategyResolver(5, originalKey)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Registers a custom resolution function such that the container calls this\r\n   * function for each request to obtain the instance.\r\n   * @param key The key that identifies the dependency at resolution time;\r\n   * usually a constructor function.\r\n   * @param resolver The resolver to use when the dependency is needed.\r\n   * @return The resolver that was registered.\r\n   */\r\n  public registerResolver<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>,\r\n    resolver: Resolver\r\n  ): Resolver {\r\n    validateKey(key);\r\n\r\n    const allResolvers = this._resolvers;\r\n    const result = allResolvers.get(key);\r\n\r\n    if (result === undefined) {\r\n      allResolvers.set(key, resolver);\r\n    } else if (result.strategy === 4) {\r\n      result.state.push(resolver);\r\n    } else {\r\n      allResolvers.set(key, new StrategyResolver(4, [result, resolver]));\r\n    }\r\n\r\n    return resolver;\r\n  }\r\n\r\n  /**\r\n   * Registers a type (constructor function) by inspecting its registration\r\n   * annotations. If none are found, then the default singleton registration is\r\n   * used.\r\n   * @param key The key that identifies the dependency at resolution time;\r\n   * usually a constructor function.\r\n   * @param fn The constructor function to use when the dependency needs to be\r\n   * instantiated. This defaults to the key value when fn is not supplied.\r\n   */\r\n  public autoRegister<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: Primitive, fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver;\r\n  public autoRegister<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: DependencyCtor<TBase, TImpl, TArgs>, fn?: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver;\r\n  public autoRegister<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>, fn?: DependencyCtorOrFunctor<TBase, TImpl, TArgs>): Resolver {\r\n    fn = fn === undefined ? key as DependencyCtor<TBase, TImpl, TArgs> : fn;\r\n\r\n    if (typeof fn === 'function') {\r\n      const registration = metadata.get(metadata.registration, fn);\r\n\r\n      if (registration === undefined) {\r\n        return this.registerResolver(key, new StrategyResolver(1, fn));\r\n      }\r\n\r\n      return registration.registerResolver(this, key, fn);\r\n    }\r\n\r\n    return this.registerResolver(key, new StrategyResolver(0, fn));\r\n  }\r\n\r\n  /**\r\n   * Registers an array of types (constructor functions) by inspecting their\r\n   * registration annotations. If none are found, then the default singleton\r\n   * registration is used.\r\n   * @param fns The constructor function to use when the dependency needs to be instantiated.\r\n   */\r\n  public autoRegisterAll(fns: DependencyCtor<any, any, any>[]): void {\r\n    let i = fns.length;\r\n    while (i--) {\r\n      this.autoRegister<any, any, any>(fns[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unregisters based on key.\r\n   * @param key The key that identifies the dependency at resolution time; usually a constructor function.\r\n   */\r\n  public unregister(key: any): void {\r\n    this._resolvers.delete(key);\r\n  }\r\n\r\n  /**\r\n   * Inspects the container to determine if a particular key has been registred.\r\n   * @param key The key that identifies the dependency at resolution time; usually a constructor function.\r\n   * @param checkParent Indicates whether or not to check the parent container hierarchy.\r\n   * @return Returns true if the key has been registred; false otherwise.\r\n   */\r\n  public hasResolver<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>, checkParent: boolean = false): boolean {\r\n    validateKey(key);\r\n\r\n    return (\r\n      this._resolvers.has(key) ||\r\n      (checkParent &&\r\n        this.parent !== null &&\r\n        this.parent.hasResolver(key, checkParent))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets the resolver for the particular key, if it has been registered.\r\n   * @param key The key that identifies the dependency at resolution time; usually a constructor function.\r\n   * @return Returns the resolver, if registred, otherwise undefined.\r\n   */\r\n  public getResolver<\r\n    TStrategyKey extends keyof StrategyState<TBase, TImpl, TArgs>,\r\n    TBase,\r\n    TImpl extends Impl<TBase> = Impl<TBase>,\r\n    TArgs extends Args<TBase> = Args<TBase>\r\n  >(\r\n    key: PrimitiveOrDependencyCtorOrFunctor<TBase, TImpl, TArgs>\r\n  ): StrategyResolver<TBase, TImpl, TArgs, TStrategyKey> {\r\n    return this._resolvers.get(key);\r\n  }\r\n\r\n  /**\r\n   * Resolves a single instance based on the provided key.\r\n   * @param key The key that identifies the object to resolve.\r\n   * @return Returns the resolved instance.\r\n   */\r\n  public get<TBase, TResolver extends NewInstance<TBase> | Lazy<TBase> | Factory<TBase> | Optional<TBase> | Parent<TBase> | All<TBase>>(\r\n    key: TResolver): ResolvedValue<TResolver>;\r\n  public get<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>): ImplOrAny<TImpl>;\r\n  public get<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: typeof Container): Container;\r\n  public get<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs> | typeof Container): ImplOrAny<TImpl> | Container {\r\n    validateKey(key);\r\n\r\n    if (key === Container) {\r\n      return this;\r\n    }\r\n\r\n    if (resolverDecorates(key)) {\r\n      return key.get(this, key);\r\n    }\r\n\r\n    const resolver = this._resolvers.get(key);\r\n\r\n    if (resolver === undefined) {\r\n      if (this.parent === null) {\r\n        return this.autoRegister(key as DependencyCtor<TBase, TImpl, TArgs>).get(this, key);\r\n      }\r\n\r\n      const registration = metadata.get(metadata.registration, key);\r\n\r\n      if (registration === undefined) {\r\n        return this.parent._get(key);\r\n      }\r\n\r\n      return registration.registerResolver(\r\n        this, key, key as DependencyCtorOrFunctor<TBase, TImpl, TArgs>).get(this, key);\r\n    }\r\n\r\n    return resolver.get(this, key);\r\n  }\r\n\r\n  public _get(key) {\r\n    const resolver = this._resolvers.get(key);\r\n\r\n    if (resolver === undefined) {\r\n      if (this.parent === null) {\r\n        return this.autoRegister(key).get(this, key);\r\n      }\r\n\r\n      return this.parent._get(key);\r\n    }\r\n\r\n    return resolver.get(this, key);\r\n  }\r\n\r\n  /**\r\n   * Resolves all instance registered under the provided key.\r\n   * @param key The key that identifies the objects to resolve.\r\n   * @return Returns an array of the resolved instances.\r\n   */\r\n  public getAll<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>): ImplOrAny<TImpl>[] {\r\n    validateKey(key);\r\n\r\n    const resolver = this._resolvers.get(key);\r\n\r\n    if (resolver === undefined) {\r\n      if (this.parent === null) {\r\n        return _emptyParameters;\r\n      }\r\n\r\n      return this.parent.getAll(key);\r\n    }\r\n\r\n    if (resolver.strategy === 4) {\r\n      const state = resolver.state;\r\n      let i = state.length;\r\n      const results = new Array(i);\r\n\r\n      while (i--) {\r\n        results[i] = state[i].get(this, key);\r\n      }\r\n\r\n      return results;\r\n    }\r\n\r\n    return [resolver.get(this, key)];\r\n  }\r\n\r\n  /**\r\n   * Creates a new dependency injection container whose parent is the current container.\r\n   * @return Returns a new container instance parented to this.\r\n   */\r\n  public createChild(): Container {\r\n    const child = new Container(this._configuration);\r\n    child.root = this.root;\r\n    child.parent = this;\r\n    return child;\r\n  }\r\n\r\n  /**\r\n   * Invokes a function, recursively resolving its dependencies.\r\n   * @param fn The function to invoke with the auto-resolved dependencies.\r\n   * @param dynamicDependencies Additional function dependencies to use during invocation.\r\n   * @return Returns the instance resulting from calling the function.\r\n   */\r\n  public invoke<TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n    dynamicDependencies?: TArgs[number][]\r\n  ): ImplOrAny<TImpl> {\r\n    try {\r\n      let handler = this._handlers.get(fn);\r\n\r\n      if (handler === undefined) {\r\n        handler = this._createInvocationHandler(fn);\r\n        this._handlers.set(fn, handler);\r\n      }\r\n\r\n      return handler.invoke(this, dynamicDependencies);\r\n    } catch (e) {\r\n      // @ts-expect-error AggregateError returns an Error in its type hence it fails (new ...) but it's fine\r\n      throw new AggregateError(\r\n        `Error invoking ${fn.name}. Check the inner error for details.`,\r\n        e as Error | undefined,\r\n        true\r\n      );\r\n    }\r\n  }\r\n\r\n  public _createInvocationHandler\r\n    <TBase, TImpl extends Impl<TBase> = Impl<TBase>, TArgs extends Args<TBase> = Args<TBase>>(\r\n      fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs> & { inject?: any; }\r\n    ): InvocationHandler<TBase, TImpl, TArgs> {\r\n    let dependencies;\r\n\r\n    if (fn.inject === undefined) {\r\n      dependencies =\r\n        metadata.getOwn(metadata.paramTypes, fn) || _emptyParameters;\r\n    } else {\r\n      dependencies = [];\r\n      let ctor = fn;\r\n      while (typeof ctor === 'function') {\r\n        dependencies.push(...getDependencies(ctor));\r\n        ctor = Object.getPrototypeOf(ctor);\r\n      }\r\n    }\r\n\r\n    const invoker = metadata.getOwn(metadata.invoker, fn) || classInvoker;\r\n\r\n    const handler = new InvocationHandler(fn, invoker, dependencies);\r\n    return this._onHandlerCreated !== undefined\r\n      ? this._onHandlerCreated(handler)\r\n      : handler;\r\n  }\r\n}\r\n\r\nexport type ResolvedValue<T> =\r\n  T extends (new (...args: any[]) => infer R)\r\n    ? R\r\n    : T extends (abstract new (...args: any[]) => infer R)\r\n      ? R\r\n      : T extends Factory<infer R>\r\n        ? (...args: unknown[]) => R\r\n        : T extends Lazy<infer R>\r\n          ? () => R\r\n          : T extends NewInstance<infer R>\r\n            ? R\r\n            : T extends Optional<infer R>\r\n              ? R | null\r\n              : T extends All<infer R>\r\n                ? R[]\r\n                : T extends Parent<infer R>\r\n                  ? R | null\r\n                  : T extends [infer T1, ...infer T2]\r\n                    ? [ResolvedValue<T1>, ...ResolvedValue<T2>]\r\n                    : T;\r\n\r\n/**\r\n * Resolve a key, or list of keys based on the current container.\r\n * \r\n * @example\r\n * ```ts\r\n * import { resolve } from 'aurelia-framework';\r\n * // or\r\n * // import { Container, resolve } from 'aurelia-dependency-injection';\r\n * \r\n * class MyCustomElement {\r\n *  someService = resolve(MyService);\r\n * }\r\n * ```\r\n */\r\nexport function resolve<K extends any>(key: K): ResolvedValue<K>;\r\nexport function resolve<K extends any[]>(...keys: K): ResolvedValue<K>\r\nexport function resolve<K extends any[]>(...keys: K) {\r\n  if (currentContainer == null) {\r\n    throw new Error(`There is not a currently active container to resolve \"${String(keys)}\". Are you trying to \"new SomeClass(...)\" that has a resolve(...) call?`);\r\n  }\r\n  \r\n  return keys.length === 1\r\n    ? currentContainer.get(keys[0])\r\n    : keys.map(containerGetKey, currentContainer);\r\n}\r\n\r\nfunction containerGetKey(this: Container, key: any) {\r\n  return this.get(key);\r\n}\r\n","import './internal';\r\nimport { metadata } from 'aurelia-metadata';\r\nimport { Container } from './container';\r\nimport { DependencyCtorOrFunctor, ImplOrAny, Impl, Args, DependencyCtor, DependencyFunctor } from './types';\r\n\r\n/**\r\n * Decorator: Specifies a custom Invoker for the decorated item.\r\n */\r\nexport function invoker<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>>(\r\n  value: Invoker<TBase, TImpl, TArgs>\r\n): (target: DependencyCtor<TBase, TImpl, TArgs>) => void {\r\n  return target => {\r\n    metadata.define(metadata.invoker, value, target);\r\n  };\r\n}\r\n\r\n/**\r\n * Decorator: Specifies that the decorated item should be called as a factory\r\n * function, rather than a constructor.\r\n */\r\nexport function invokeAsFactory<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>>(\r\n  potentialTarget?: DependencyCtor<TBase, TImpl, TArgs>\r\n): void | ((target: DependencyCtor<TBase, TImpl, TArgs>) => void) {\r\n  const deco = (target: DependencyCtor<TBase, TImpl, TArgs>) => {\r\n    metadata.define(metadata.invoker, FactoryInvoker.instance, target);\r\n  };\r\n\r\n  return potentialTarget ? deco(potentialTarget) : deco;\r\n}\r\n\r\n/**\r\n * A strategy for invoking a function, resulting in an object instance.\r\n */\r\nexport interface Invoker<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>> {\r\n  /**\r\n   * Invokes the function with the provided dependencies.\r\n   * @param fn The constructor or factory function.\r\n   * @param dependencies The dependencies of the function call.\r\n   * @return The result of the function invocation.\r\n   */\r\n  invoke(\r\n    container: Container,\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n    dependencies: TArgs\r\n  ): ImplOrAny<TImpl>;\r\n\r\n  /**\r\n   * Invokes the function with the provided dependencies.\r\n   * @param fn The constructor or factory function.\r\n   * @param staticDependencies The static dependencies of the function.\r\n   * @param dynamicDependencies Additional dependencies to use during\r\n   * invocation.\r\n   * @return The result of the function invocation.\r\n   */\r\n  invokeWithDynamicDependencies(\r\n    container: Container,\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n    staticDependencies: TArgs[number][],\r\n    dynamicDependencies: TArgs[number][]\r\n  ): ImplOrAny<TImpl>;\r\n}\r\n\r\n/**\r\n * An Invoker that is used to invoke a factory method.\r\n */\r\nexport class FactoryInvoker<\r\n  TBase,\r\n  TImpl extends Impl<TBase> = Impl<TBase>,\r\n  TArgs extends Args<TBase> = Args<TBase>\r\n  > implements Invoker<TBase, TImpl, TArgs> {\r\n  /**\r\n   * The singleton instance of the FactoryInvoker.\r\n   */\r\n  public static instance: FactoryInvoker<any>;\r\n\r\n  /**\r\n   * Invokes the function with the provided dependencies.\r\n   * @param container The calling container.\r\n   * @param fn The constructor or factory function.\r\n   * @param dependencies The dependencies of the function call.\r\n   * @return The result of the function invocation.\r\n   */\r\n  public invoke(\r\n    container: Container,\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n    dependencies: TArgs\r\n  ): ImplOrAny<TImpl> {\r\n    let i = dependencies.length;\r\n    const args = new Array(i);\r\n\r\n    while (i--) {\r\n      args[i] = container.get(dependencies[i]);\r\n    }\r\n\r\n    return ((fn as DependencyFunctor<TBase, TImpl, TArgs>).apply(undefined, args as TArgs)) as ImplOrAny<TImpl>;\r\n  }\r\n\r\n  /**\r\n   * Invokes the function with the provided dependencies.\r\n   * @param container The calling container.\r\n   * @param fn The constructor or factory function.\r\n   * @param staticDependencies The static dependencies of the function.\r\n   * @param dynamicDependencies Additional dependencies to use during invocation.\r\n   * @return The result of the function invocation.\r\n   */\r\n  public invokeWithDynamicDependencies(\r\n    container: Container,\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>,\r\n    staticDependencies: TArgs[number][],\r\n    dynamicDependencies: TArgs[number][]\r\n  ): ImplOrAny<TImpl> {\r\n    let i = staticDependencies.length;\r\n    let args = new Array(i);\r\n\r\n    while (i--) {\r\n      args[i] = container.get(staticDependencies[i]);\r\n    }\r\n\r\n    if (dynamicDependencies !== undefined) {\r\n      args = args.concat(dynamicDependencies);\r\n    }\r\n\r\n    return (fn as DependencyFunctor<TBase, TImpl, TArgs>).apply(undefined, args as TArgs) as ImplOrAny<TImpl>;\r\n  }\r\n}\r\n\r\nFactoryInvoker.instance = new FactoryInvoker();\r\n","import './internal';\r\nimport { Resolver } from './resolvers';\r\nimport { Container } from './container';\r\nimport { metadata } from 'aurelia-metadata';\r\nimport {\r\n  DependencyCtorOrFunctor,\r\n  PrimitiveOrDependencyCtor,\r\n  Impl,\r\n  Args,\r\n  DependencyCtor\r\n} from './types';\r\n\r\n/**\r\n * Decorator: Specifies a custom registration strategy for the decorated\r\n * class/function.\r\n */\r\nexport function registration<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>>(\r\n  value: Registration<TBase, TImpl, TArgs>) {\r\n  return (target: DependencyCtor<TBase, TImpl, TArgs>) => {\r\n    metadata.define(metadata.registration, value, target);\r\n  };\r\n}\r\n\r\n/**\r\n * Decorator: Specifies to register the decorated item with a \"transient\"\r\n * lifetime.\r\n */\r\nexport function transient<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>>(\r\n  key?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>) {\r\n  return registration(new TransientRegistration<TBase, TImpl, TArgs>(key));\r\n}\r\n\r\n/**\r\n * Decorator: Specifies to register the decorated item with a \"singleton\"\r\n * lifetime.\r\n */\r\nexport function singleton(registerInChild?: boolean);\r\nexport function singleton<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>>(\r\n  key?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>, registerInChild?: boolean);\r\nexport function singleton<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>>(\r\n  keyOrRegisterInChild?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs> | boolean, registerInChild: boolean = false) {\r\n  return registration<TBase, TImpl, TArgs>(\r\n    new SingletonRegistration<TBase, TImpl, TArgs>(keyOrRegisterInChild, registerInChild)\r\n  );\r\n}\r\n\r\n/**\r\n * Customizes how a particular function is resolved by the Container.\r\n */\r\nexport interface Registration<\r\n  TBase,\r\n  TImpl extends Impl<TBase>,\r\n  TArgs extends Args<TBase>> {\r\n  /**\r\n   * Called by the container to register the resolver.\r\n   * @param container The container the resolver is being registered with.\r\n   * @param key The key the resolver should be registered as.\r\n   * @param fn The function to create the resolver for.\r\n   * @return The resolver that was registered.\r\n   */\r\n  registerResolver(\r\n    container: Container,\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>,\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>\r\n  ): Resolver;\r\n}\r\n\r\n/**\r\n * Used to allow functions/classes to indicate that they should be registered as\r\n * transients with the container.\r\n */\r\nexport class TransientRegistration<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>>\r\n  implements Registration<TBase, TImpl, TArgs> {\r\n  /** @internal */\r\n  public _key?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>;\r\n\r\n  /**\r\n   * Creates an instance of TransientRegistration.\r\n   * @param key The key to register as.\r\n   */\r\n  constructor(key?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>) {\r\n    this._key = key;\r\n  }\r\n\r\n  /**\r\n   * Called by the container to register the resolver.\r\n   * @param container The container the resolver is being registered with.\r\n   * @param key The key the resolver should be registered as.\r\n   * @param fn The function to create the resolver for.\r\n   * @return The resolver that was registered.\r\n   */\r\n  public registerResolver(\r\n    container: Container,\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>,\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>\r\n  ): Resolver {\r\n    const existingResolver = container.getResolver(this._key || key);\r\n    return existingResolver === undefined\r\n      ? container.registerTransient<TBase, TImpl, TArgs>(\r\n        (this._key || key) as string,\r\n        fn as DependencyCtorOrFunctor<TBase, TImpl, TArgs>)\r\n      : existingResolver;\r\n  }\r\n}\r\n\r\n/**\r\n * Used to allow functions/classes to indicate that they should be registered as\r\n * singletons with the container.\r\n */\r\nexport class SingletonRegistration<TBase, TImpl extends Impl<TBase>, TArgs extends Args<TBase>>\r\n  implements Registration<TBase, TImpl, TArgs> {\r\n  /** @internal */\r\n  public _registerInChild: boolean;\r\n\r\n  /** @internal */\r\n  public _key?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>;\r\n\r\n  /**\r\n   * Creates an instance of SingletonRegistration.\r\n   * @param key The key to register as.\r\n   */\r\n  constructor(\r\n    keyOrRegisterInChild?: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs> | boolean,\r\n    registerInChild: boolean = false) {\r\n    if (typeof keyOrRegisterInChild === 'boolean') {\r\n      this._registerInChild = keyOrRegisterInChild;\r\n    } else {\r\n      this._key = keyOrRegisterInChild;\r\n      this._registerInChild = registerInChild;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called by the container to register the resolver.\r\n   * @param container The container the resolver is being registered with.\r\n   * @param key The key the resolver should be registered as.\r\n   * @param fn The function to create the resolver for.\r\n   * @return The resolver that was registered.\r\n   */\r\n  public registerResolver(\r\n    container: Container,\r\n    key: PrimitiveOrDependencyCtor<TBase, TImpl, TArgs>,\r\n    fn: DependencyCtorOrFunctor<TBase, TImpl, TArgs>\r\n  ): Resolver {\r\n    const targetContainer = this._registerInChild ? container : container.root;\r\n    const existingResolver = targetContainer.getResolver(this._key || key);\r\n    return existingResolver === undefined\r\n      ? targetContainer.registerSingleton(this._key || key, fn)\r\n      : existingResolver;\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}